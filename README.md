# О проекте RelaxДанный язык начал разрабатываться 30 декабря 2020 года. Разработка ведется одним человеком._Relax_ - это язык, в котором будет минимум ограничений, максимум сахара. Как работает язык? Сначала компилятор компилирует код _Relax_ в код _Relasm_(Ассемблер релакса, текстовый вид байт-кода). Затем компилятор ассемблера преобразует его в байт-код, который может исполнять виртуальная машина, то есть _RVM_.# ДокументацияRelasm состоит из набора инструкций, как в ассемблере или CIL-коде. Они делятся на 2 уровня: верхний уровень и нижний уровень. К верхнему уровню относятся инструкции создания классов, методов, полей. А к нижнему уровню относятся инструкции, находящиеся внутри метода или функции.Далее будут описаны все доступные в _Relasm_ инструкции.1. `mclass` создает главный класс, то есть класс, в котором есть метод _Main_. В аргументы принимает название класса, который нужно создать. Данная инструкция относится к верхнему уровню.	Пример записи:	```	mclass MyProgram	```2. `new` создает новый объект заданного класса и помещает на стек. Данная инструкция относится к нижнему уровню. Из стека принимает значения, которые передаются в параметры конструктора. В параметры принимает:	* _Класс, объект которого нужно создать_.	* _Список параметров_. В скобках через запятую перечисляются типы данных параметров нужного нам конструктора.	Примеры записей:	```	new Relax.Object()	new Dog(Relax.Int32)	new Cat(Relax.Int32, Relax.String)	```3. `class` создает новый класс. В аргументы принимает название класса, который нужно создать. Данная инструкция относится к верхнему уровню.		Пример записи:	```	class Cat	```4. `method` создает метод класса. Данная инструкция относится к верхнему уровню. В параметры принимает:	* Модификатор доступа:		* public		* private		* protected	* Статичность		* static		* instance	* Имя класса, в который нужно добавить метод.	* Имя метода	* Список параметров(нужно указывать тип данных и имя)	Пример записи:	```	method public static MainClass.PrintStrInt(Relax.String str, Relax.Int32 num):		;code...	```5. `callm` вызывает методы класса. Данная инструкция относится к нижнему уровню. В параметры принимает:	* _Класс, в котором находится метод_. Записывается полное имя класса.	* _Список параметров_. В скобках через запятую перечисляются типы данных параметров нужного нам метода.	Пример записи:	```	callm std static Relax.Console.Write(Relax.String)	```6. `get` добавляет на стек значение локальной переменной. В параметры принимает имя локальной переменной. Данная инструкция относится к нижнему уровню. В байт-коде пишется не имя, а четырёхбайтовый id	Пример записи:	```	get myVar	```7. `push.str` добавляет Relax.String на стек. Строку, которую нужно добавить, инструкция принимает в параметры. Данная инструкция относится к нижнему уровню.	Пример записи:	```	push.str "hello world"	```8. `push.int32` добавляет Relax.Int32 на стек. В параметры принимает число, которое нужно добавить. Данная инструкция относится к нижнему уровню.	Пример записи:	```	push.int32 56	```9. `return` выходит из метода и, в случае если возвращаемый тип данных не равен void из стека будет браться значение и записываться в стек родительского фрейма. Данная инструкция относится к нижнему уровню.	Пример записи:	```	return	```10. `set` устанавливает значение локальной переменной. В аргументы принимает название локальной переменной. Со стека берет значение и присваивает его в локальную переменную. Данная инструкция относится к нижнему уровню.	Пример записи:	```	set lol	```11. `local` создает локальную переменную с определенным типом данных. В аргументы принимает название переменной и тип данных. Данная инструкция относится к нижнему уровню.	Пример записи:	```	local var Relax.String	```12. `add` операция складывания. Складывает 2 числовых значения со стека и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	add	```	Пример кода:	```	push.int 10	push.int 90	add	```	После выполнения этого кода на стеке будет число 100.13. `dup` получает объект со стека и вставляет его на стек дважды. Данная инструкция относится к нижнему уровню.	Пример записи:	```	dup	```14. `jmp` перемещает выполнение кода на определенную метку. В параметры принимает название метки. А в байт-коде она принимает число, означающее количество инструкций на которое нужно переместить выполнение кода, относительно начала метода. Данная инструкция относится к нижнему уровню. 	Пример записи:	```	jmp tag	```    Как создавать метки?    ```    tag:    ```15. `jmpif` то же самое, что и jmp, но перемещает выполнение кода только, если на стеке лежит значение true типа данных Relax.Bool. Данная инструкция относится к нижнему уровню.		Пример записи:	```	jmpif tag	```16. `gc` очищает мусор в куче. Использовать её вам вряд ли понадобится, так как RVM каждые 20 инструкций сама очищает мусор. Данная инструкция относится к нижнему уровню.	Пример записи:	```	gc	```17. `newarr` создает Relax.Array определенного типа, который передается в аргументы, и с определенным размером, который берется со стека. Ссылка на созданный массив помещается на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	newarr Relax.Int32	```	Особенность типа Relax.Array. Чтобы создать переменную под массив нужно в угловых скобках указать тип, который хранит массив.	Пример:	```	local myArr Relax.Array<Relax.String>	newarr Relax.String	set myArr	```18. `getarr` получает данные из массива по индексу. Со стека берет ссылку на массив и индекс типа Relax.Int32. Затем помещает на стек значение из массива. Данная инструкция относится к нижнему уровню.	Пример записи:	```	getarr	```	Пример использования:	```	push.int32 10 ;Индекс	get arr ;Получение ссылки на массив	getarr	```    19. `setarr` устанавливает данные в массиве по индексу. Со стека берет ссылку на массив, индекс типа Relax.Int32, в который нужно установить значение, и само значение. Данная инструкция относится к нижнему уровню.	Пример записи:	```	setarr	```	Пример использования:	```	push.str "я - десятый элемент в массиве" ;Значение(допустим у нас массив строк)	push.int32 10 ;Индекс	get arr ;Получение ссылки на массив	setarr	```20. `push.bool` помещает значение Relax.Bool на стек. В аргументы принимает true или false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	push.bool true	```21. `push.float` помещает значение Relax.Float на стек. В аргументы принимает число с точкой. Данная инструкция относится к нижнему уровню.		Пример записи:	```	push.float 3.14	```22. `sub` операция вычитания. Вычитает из первого числового значения со стека второе значение и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	sub	```	Пример кода:	```	push.int 10	push.int 90	sub	```	После выполнения этого кода на стеке будет число 80.23. `mul` операция умножения. Умножает 2 числовых значения со стека и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	mul	```	Пример кода:	```	push.int 10	push.int 90	mul	```	После выполнения этого кода на стеке будет число 900.24. `div` операция деления. Делит первое числовое значение со стека на второе значение и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	div	```	Пример кода:	```	push.int 10	push.int 90	div	```	После выполнения этого кода на стеке будет число 9.25. `cast` приводит значение к другому типу данных и результат помещает на стек. В параметры принимает тип данных, к которому нужно привести значение. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cast Relax.Int32	```	Пример кода:	```	push.float 3.14	cast Relax.Int32	```	После выполнения этого кода на стеке будет число 3(Relax.Int32).26. `.maxstack` указывает размер стека в методе. От размера стека зависит то, сколько значений может там находится одновременно. Вызывать эту инструкцию нужно один раз в методе. Если её не вызывать, то размер стека будет равен нулю. Данная инструкция относится к нижнему уровню.		Пример записи:	```	.maxstack 2	```	Пример использования:	```	.maxstack 1	push.int32 456	callm static Relax.Console.Print(Relax.Int32)	```	Пример ошибки:	```	.maxstack 1	push.int32 456	push.str "hello world"	callm static Relax.Console.Print(Relax.String)	callm static Relax.Console.Print(Relax.Int32)	```	Ошибка заключается в том, что в стеке одновременно находится 2 значения, а максимальное значение в нашем случае равно 1.27. `ref` создает указатель на значение со стека. В параметры принимает тип данных указателя. На стек помещает созданный указатель типа Relax.Pointer. Данная инструкция относится к нижнему уровню.		Пример записи:	```	ref Relax.Int32	```	Пример кода:	```	push.int32 10	ref Relax.Int32	local pointer Relax.Pointer<Relax.Int32>	set pointer	```	Как вы могли заметить переменные указателя объявляются по тому же принципу, что и массивы.28. `deref` берет со стека указатель и возвращает на стек значение этого указателя. Данная инструкция относится к нижнему уровню.		Пример записи:	```	deref	```	Пример кода:	```	push.int32 10	ref Relax.Int32	deref	callm static Relax.Console.Print(Relax.Int32)	```	Запись числа 10 на стек -> создание указателя на число 10 -> разыменование указателя, тем самым, получая исходное число 10 -> вывод числа на консоль. 29. `setpd` устанавливает новое значение по адресу, на который указывает указатель. Данная инструкция относится к нижнему уровню.		Пример записи:	```	setpd	```	Пример кода:	```	local var Relax.Int32 ;Объявление переменной, с которой будем манипулировать	local pointer Relax.Pointer<Relax.Int32> ; Указатель, который будет указывать на переменную var	push.int32 10	set var ;Устанавливаем в переменную var значение 10	get var	ref Relax.Int32	set pointer ;Создаем указатель на переменную var и присваиваем её в указатель pointer	push.int32 20	get pointer	setpd ;Меняем значение переменной var через указатель pointer	get var	callm static Relax.Console.Print(Relax.Int32) ;Выводим новое значение переменной var	```30. `field` создает поле класса. Данная инструкция относится к верхнему уровню.	В параметры принимает:	* Статичность(static или instance)	* Тип данных	* Название содержащего поле класса	* Имя поля	Пример записи:	```	field instance Relax.Int32 Dog.Speed	```31. `getfield` получает значение поля объекта со стека и помещает его на стек. В параметры принимает название поля. Данная инструкция относится к нижнему уровню.		Пример записи:	```	getfield Fieldname	```	Пример кода:	```	new Dog() ;Создаем объект класса Dog	getfield Name ;Получаем поле Name у созданного объекта	```32. `setfield` устанавливает значение поля объекта со стека. Значение берется на стеке. В параметры принимает название поля. Данная инструкция относится к нижнему уровню.		Пример записи:	```	setfield Fieldname	```	Пример кода:	```	new Dog() ;Создаем объект класса Dog	push.str "Shery"	setfield Name ;Присваиваем полю Name значение "Shery"	```33. `this` получает ссылку на объект из которого вызван метод и записывает её на стек. Используется только в instance-методах. При использовании его в static-методе на стек запишется null. Данная инструкция относится к нижнему уровню.		Пример записи:	```	this	```34. `equal` получает со стека 2 примитива и сравнивает их, если они равны, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	equal	```	Пример кода:	```	push.int32 10	push.int32 10	equal	```	В результате на стеке будет лежать значение true.