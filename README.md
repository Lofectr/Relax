# О проекте RelaxДанный язык начал разрабатываться 30 декабря 2020 года. Разработка ведется одним человеком._Relax_ - это язык, в котором будет минимум ограничений, максимум сахара. Как работает язык? Сначала компилятор компилирует код _Relax_ в код _Relasm_(Ассемблер релакса, текстовый вид байт-кода). Затем компилятор ассемблера преобразует его в байт-код, который может исполнять виртуальная машина, то есть _RVM_.# ДокументацияДалее будут описаны все доступные в _Relasm_ инструкции.* `mclass`. Данная инструкция создает главный класс, то есть класс, в котором есть метод _Main_. В аргументы принимает название класса, который нужно создать. Со стека данные не берёт. В байт-коде обозначается байтом 1.<br>Пример кода:	```	mclass MyProgram	```* `new`. Данная инструкция создает новый объект заданного класса и помещает его в кучу и на стек. Из стека принимает значения, которые передаются в параметры конструктора. В байт-коде обозначается байтом 2. В параметры принимает:	* _Is std_(_std_ - класс определён в виртуальной машине, _usr_ - класс написан на языке релакс вами либо другими разработчиками).	* _Класс, объект которого нужно создать_. Записывается полное имя класса, включая namespaces и классы в котором он находится, разделяя точкой.	* _Список параметров_. Далее в скобках через запятую перечисляются типы данных параметров нужного нам конструктора.<br>	Пример кода:	```	new std Relax.Object()	```	Добавляем строку "my label!" на стек. Далее вызываем инструкцию new, которая создает объект стандартного класса Relax.GUI.Label и вызывается конструктор с параметрами (Relax.String).* `class`. Создает новый класс. В аргументы принимает название класса, который нужно создать. Со стека данные не берёт. В байт-коде обозначается байтом 3.<br>Пример кода:	```	class MyNamespace.Cat	```* `method`. Создает новый метод класса. В байт-коде обозначается байтом 4. При вызове метода параметры записываются в стек. В параметры принимает:	* Модификатор доступа:		* public		* private		* protected	* Статический или нет		* static		* instance	* Имя класса, в который нужно добавить метод.	* Имя метода	* Список параметров(нужно указывать тип данных и имя)	Пример кода:	```	mclass MainClass	method public static MainClass.Lol(Relax.String str, Relax.Int32 num):		callm std static Relax.Console.Write(Relax.String)		callm std static Relax.Console.Write(Relax.Int32)	```* `callm`. Может вызывать методы класса. В параметры принимает:	* _Is std_(_std_ - стандартный метод(то есть определён в виртуальной машине), _usr_ - метод написан на языке relax вами либо другими разработчиками).	* _Класс, объект которого нужно создать_. Записывается полное имя класса, включая namespaces и классы в котором он находится, разделяя точкой.	* _Список параметров_. Далее в скобках через запятую перечисляются типы данных параметров нужного нам конструктора. В байт-коде обозначается байтом 5.<br>	Пример кода:	```	push.str "hello world"	callm std static Relax.Console.Write(Relax.String)	```	Добавляется на стек строка "hello world", вызывается метод Relax.Console.Write, в который передается строка. Результат: hello world* `get`. Добавляет на стек значение локальной переменной. В параметры принимает имя локальной переменной, которая будет добавлена в стек. В байт-коде нужно писать вместо имени id. В байт-коде обозначается байтом 6.<br>	Пример кода:	```	local myVar Relax.String	push.str "hello world"	set myVar	get myVar	callm std static Relax.Console.Write(Relax.String)	```	Создаем переменную с именем myVar и типом данных Relax.String. Добавляем строку "hello world" на стек. Записываем в переменную myVar значение из стека(то есть "hello world"). Получаем значение переменной myVar на стек. Вызываем метод Relax.Console.Write, в который передается Relax.String. Как результат на консоль выведится hello world.* `push.str`. Добавляет Relax.Int32 в кучу и на стек. В параметры принимает строку, которую нужно добавить. В байт-коде обозначается байтом 7.<br>	Пример кода:	```	push.str "hello world"	callm std static Relax.Console.Write(Relax.String)	```	Добавляется на стек строка "hello world", вызывается метод Relax.Console.Write, в который передается строка. Результат - hello world.* `push.int32`. Добавляет Relax.Int32 в кучу и на стек. В параметры принимает число, которое нужно добавить. В байт-коде обозначается байтом 8.<br>	Пример кода:	```	push.int32 56	callm std static Relax.Console.Write(Relax.Int32)	```	Добавляется на стек число 56, вызывается метод Relax.Console.Write, в который передается Relax.Int32. Результат - 56.* `return`. Выходит из метода и, в случае если возвращаемый тип данных не равен void из стека будет браться значение и записываться в стек метода, который вызывал данный. В байт-коде обозначается байтом 9.<br>	Пример кода:	```	mclass MainClass	method public static void MainClass.Main():		push.int32 56		callm usr static MainClass.Lol(Relax.Int32)		callm std static Relax.Console.Write(Relax.Int32)	method public static Relax.Int32 MainClass.Lol(Relax.Int32 num):		push.int32 1		add		return	```	Записываем в стек метода Main число 56, вызываем метод Lol. В методе Lol инкрементируем значение, переданное в параметры и возвращаем его. В методе Main возвращаемый результат выводим на консоль. Результат - 57.* `set`. Устанавливает значение локальной переменной. В аргументы принимает название локальной переменной. Со стека берет значение и присваивает его в локальную переменную. В байт-коде обозначается байтом 10.<br>	Пример кода:	```	local lol Relax.Float	push.float 1.89	set lol	get lol	callm std static Relax.Console.Write(Relax.Float)	```	Создаем локальную переменную lol с типом данных Relax.Float. Записываем значение 1.89 на стек. Устанавливаем значение для переменной lol из стека. Получаем значение lol. Выводим на консоль значение из стека. Результат - 1.89* `local`. Создает локальную переменную с определенным типом данных. В аргументы принимает название переменной и тип данных. В байт-коде обозначается байтом 11.<br>	Пример кода:	```	local lol Relax.String	push.str "Relax it's cool!"	set lol	get lol	callm std static Relax.Console.Write(Relax.String)	```	Создаем локальную переменную lol с типом данных Relax.String. Записываем на стек строку "Relax it's cool!". Присваиваем значение со стека переменной lol. Получаем значение переменной lol.* `add`. Складывает 2 числовых значения со стека и помещает результат на стек. Вообще, под капотом вызывается оператор+, а то что он возвращает помещается на стек. Так что это просто сахар. В байт-коде обозначается байтом 12.<br>	Пример кода:	```	push.int32 12	push.float 1.69	add	callm std static Relax.Console.Write(Relax.Float)	```	Помещаем на стек число 12, и число 1.69, складываем их и выводим на консоль. Результат - 13.69* `dup`. Получает объект со стека и вставляет его на стек дважды. То есть, если на стеке было число 1, то после выполнения инструкции dup - будет два числа 1 на стеке. В байт-коде обозначается байтом 13.<br>	Пример кода:	```	push.str "hello world"	dup	callm std static Relax.Console.Write(Relax.String)	callm std static Relax.Console.Write(Relax.String)	```* `jmp`. Данная инструкция немного отличается в relasm от того, что в байт-коде. В relasm она принимает название метки, в которую нужно перейти. А вот в байт-коде она принимает число, означающее то, насколько байт, относительно начала метода, нужно сдвинуть обработку кода.