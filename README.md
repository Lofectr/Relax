# О проекте RelaxДанный язык начал разрабатываться 30 декабря 2020 года. Разработка ведется одним человеком._Relax_ - это язык, в котором будет минимум ограничений, максимум сахара. Как работает язык? Сначала компилятор компилирует код _Relax_ в код _Relasm_(Ассемблер релакса, текстовый вид байт-кода). Затем компилятор ассемблера преобразует его в байт-код, который может исполнять виртуальная машина, то есть _RVM_.# ДокументацияДалее будут описаны все доступные в _Relasm_ инструкции.* `mclass` создает главный класс, то есть класс, в котором есть метод _Main_. В аргументы принимает название класса, который нужно создать. Со стека данные не берёт. В байт-коде обозначается байтом 1.<br>Пример кода:	```	mclass MyProgram	```* `new` создает новый объект заданного класса и помещает его в кучу и на стек. Из стека принимает значения, которые передаются в параметры конструктора. В байт-коде обозначается байтом 2. В параметры принимает:	* _Is std_(_std_ - класс определён в виртуальной машине, _usr_ - класс написан на языке релакс вами либо другими разработчиками).	* _Класс, объект которого нужно создать_. Записывается полное имя класса, включая namespaces и классы в котором он находится, разделяя точкой.	* _Список параметров_. Далее в скобках через запятую перечисляются типы данных параметров нужного нам конструктора.<br>	Пример кода:	```	new std Relax.Object()	```	Вызываем инструкцию new, которая создает объект стандартного класса Relax.Object и вызывается конструктор без параметров.* `class` создает новый класс. В аргументы принимает название класса, который нужно создать. Со стека данные не берёт. В байт-коде обозначается байтом 3.<br>Пример кода:	```	class MyNamespace.Cat	```* `method` создает новый метод класса. В байт-коде обозначается байтом 4. В параметры принимает:	* Модификатор доступа:		* public		* private		* protected	* Статический или нет		* static		* instance	* Имя класса, в который нужно добавить метод.	* Имя метода	* Список параметров(нужно указывать тип данных и имя)	Пример кода:	```	mclass MainClass ;Создание главного класса	method public static MainClass.PrintStrInt(Relax.String str, Relax.Int32 num): ;Создание метода PrintStrInt(Relax.String, Relax.Int32)		get str ;Запись на стек параметра с именем str		callm std static Relax.Console.Write(Relax.String) ;Вывод в консоль строки из стека		get num ;Запись на стек параметра с именем num		callm std static Relax.Console.Write(Relax.Int32) ;Вывод в консоль числа из стека	```* `callm` может вызывать методы класса. В параметры принимает:	* _Is std_(_std_ - стандартный метод(то есть определён в виртуальной машине), _usr_ - метод написан на языке relax вами либо другими разработчиками).	* _Класс, в котором находится метод_. Записывается полное имя класса, включая namespaces и классы в котором он находится, разделяя точкой.	* _Список параметров_. Далее в скобках через запятую перечисляются типы данных параметров нужного нам метода. В байт-коде обозначается байтом 5.<br>	Пример кода:	```	push.str "hello world"	callm std static Relax.Console.Write(Relax.String)	```	Добавляется на стек строка "hello world", вызывается метод Relax.Console.Write, в который передается строка. Результат: hello world* `get` добавляет на стек значение локальной переменной. В параметры принимает имя локальной переменной, которая будет добавлена в стек. В байт-коде нужно писать вместо имени id. В байт-коде обозначается байтом 6.<br>	Пример кода:	```	local myVar Relax.String	push.str "hello world"	set myVar	get myVar	callm std static Relax.Console.Write(Relax.String)	```	Создаем переменную с именем myVar и типом данных Relax.String. Добавляем строку "hello world" на стек. Записываем в переменную myVar значение из стека(то есть "hello world"). Получаем значение переменной myVar на стек. Вызываем метод Relax.Console.Write, в который передается Relax.String. Как результат на консоль выведится hello world.* `push.str` добавляет строку на стек. В параметры принимает строку, которую нужно добавить. В байт-коде обозначается байтом 7.<br>	Пример кода:	```	push.str "hello world"	callm std static Relax.Console.Write(Relax.String)	```	Добавляется на стек строка "hello world", вызывается метод Relax.Console.Write, в который передается строка. Результат - hello world.* `push.int32` добавляет Relax.Int32 на стек. В параметры принимает число, которое нужно добавить. В байт-коде обозначается байтом 8.<br>	Пример кода:	```	push.int32 56	callm std static Relax.Console.Write(Relax.Int32)	```	Добавляется на стек число 56, вызывается метод Relax.Console.Write, в который передается Relax.Int32. Результат - 56.* `return` выходит из метода и, в случае если возвращаемый тип данных не равен void из стека будет браться значение и записываться в стек фрейма, который вызывал данный. В байт-коде обозначается байтом 9.<br>	Пример кода:	```	mclass MainClass	method public static void MainClass.Main():		push.int32 56		callm usr static MainClass.Lol(Relax.Int32)		callm std static Relax.Console.Write(Relax.Int32)	method public static Relax.Int32 MainClass.Lol(Relax.Int32 num):		push.int32 1		add		return	```	Записываем в стек число 56, вызываем метод Lol. В методе Lol инкрементируем значение, переданное в параметры и возвращаем его. В методе Main возвращаемый результат выводим на консоль. Результат - 57.* `set` устанавливает значение локальной переменной. В аргументы принимает название локальной переменной. Со стека берет значение и присваивает его в локальную переменную. В байт-коде обозначается байтом 10.<br>	Пример кода:	```	local lol Relax.Float	push.float 1.89	set lol	get lol	callm std static Relax.Console.Write(Relax.Float)	```	Создаем локальную переменную lol с типом данных Relax.Float. Записываем значение 1.89 на стек. Устанавливаем значение для переменной lol из стека. Получаем значение lol. Выводим на консоль значение из стека. Результат - 1.89* `local` создает локальную переменную с определенным типом данных. В аргументы принимает название переменной и тип данных. В байт-коде обозначается байтом 11.<br>	Пример кода:	```	local lol Relax.String	push.str "Relax is cool!"	set lol	get lol	callm std static Relax.Console.Write(Relax.String)	```	Создаем локальную переменную lol с типом данных Relax.String. Записываем на стек строку "Relax is cool!". Присваиваем значение со стека переменной lol. Получаем значение переменной lol.* `add` складывает 2 числовых значения со стека и помещает результат на стек. Вообще, под капотом вызывается оператор+, а то что он возвращает помещается на стек. В байт-коде обозначается байтом 12.<br>	Пример кода:	```	push.int32 12	push.float 1.69	add	callm std static Relax.Console.Write(Relax.Float)	```	Помещаем на стек число 12, и число 1.69, складываем их и выводим на консоль. Результат - 13.69* `dup` получает объект со стека и вставляет его на стек дважды. То есть, если на стеке было число 1, то после выполнения инструкции dup - будет два числа 1 на стеке, с тем же адресом в памяти. В байт-коде обозначается байтом 13.<br>	Пример кода:	```	push.str "hello world"	dup	callm std static Relax.Console.Write(Relax.String)	callm std static Relax.Console.Write(Relax.String)	```	Добавляем строку на стек, и раздваиваем её, при помощи инструкции dup. Затем 2 раза вызываем метод Relax.Console.Write. Результат: hello worldhello world.* `jmp` перемещает выполнение кода на определенную метку. Данная инструкция немного отличается в relasm от того, что в байт-коде. В relasm она принимает название метки, в которую нужно перейти. А вот в байт-коде она принимает число, означающее количество инстукций на которое нужно переместить выполнение кода, относительно начала метода. В байт-коде обозначается байтом 14.<br> Пример кода:	```	forever:	push.str "hello world"	callm std static Relax.Console.Write(Relax.String)	mp forever	```    Это пример бесконечного цикла. в начале объявляется метка forever, затем на стек добавляем строку и вызываем метод Relax.Console.Write. После этого мы возвращаемся на метку forever и так до бесконечности.* `jmpif` то же, что и jmp, но перемещает выполнение кода только, если на стеке лежит значение true типа данных Relax.Bool. В байт-коде обозначается байтом 15.	```	; Объявление переменных	local max Relax.int32 ;Количество итераций	local i Relax.int32 ;Текущая итерация	; Инициализация переменных	push.int32 10	set max	push.int32 10	set i	;Начало цикла	for:	;Если текущая итерация равна переменной max - то переходим в метку end, то есть завершаем программу.	get i	get max	callm std instance Relax.Int32.operator==(Relax.Int32)	jmpif end	;Выводим текущую итерацию на консоль	get i	callm std static Relax.Console.Write(Relax.Int32)	;Инкрементируем текущую итерацию	get i	push.int32 1	add	set i	;Переходим в метку for	jmp for	end:	```    Это цикл от 0 до 10. Результат: 123456789.* `gc` очищает мусор в куче. Его просто так лучше не использовать, так как RVM сама вызывает его, когда нужно. В байт-коде обозначается байтом 16.* `newarr` создает массив данных, определенного типа, который передается в аргументы, и с определенным размером, который берется со стека. Ссылка на созданный массив помещается на стек. В байт-коде обозначается байтом 17.	```	local myArr Relax.Array	push.int32 10	newarr Relax.Int32	set myArr	```    Создаем переменную типа Relax.Array, записываем на стек число 10, создаем новый массив на 10 элементов, записываем созданный массив в переменную.* `getarr` получает данные из массива по индексу. Со стека берет ссылку на массив и индекс(Relax.Int32). Затем помещает на стек значение из массива, по тому индексу, который был взят из стека. В байт-коде обозначается байтом 18.	```	local myArr Relax.Array	push.int32 2	newarr Relax.Int32	set myArr	push.int32 56 ;значение	push.int32 0 ;индекс	get myArr	setarr	push.int32 356 ;значение	push.int32 1 ;индекс	get myArr	setarr	push.int32 0 ;индекс	get myArr	getarr	callm std static Relax.Console.Write(Relax.Int32)	push.int32 1 ;индекс	get myArr	getarr	callm std static Relax.Console.Write(Relax.Int32)	```    Создаем массив Relax.Int32 на 2 элемента. В первый индекс записываем число 56, во второй - 356. Затем при помощи инструкции getarr получаем данные и выводим на консоль.* `setarr` устанавливает данные по индексу. 