# О проекте RelaxДанный язык начал разрабатываться 30 декабря 2020 года. Разработка ведется одним человеком._Relax_ - это язык, в котором будет минимум ограничений, максимум сахара. Как работает язык? Сначала компилятор компилирует код _Relax_ в код _Relasm_(Ассемблер релакса, текстовый вид байт-кода). Затем компилятор ассемблера преобразует его в байт-код, который может исполнять виртуальная машина, то есть _RVM_.# Для стартаRelasm состоит из набора инструкций, как в ассемблере или CIL-коде. Они делятся на 2 уровня: верхний уровень и нижний уровень. К верхнему уровню относятся инструкции создания классов, методов, полей. А к нижнему уровню относятся инструкции, находящиеся внутри метода или функции.### Hello, world!Вот так выглядет простая программа "Hello, world!":```mclass MainClassmethod public static void MainClass.Main():	.maxstack 1	push.str "Hello, world!"	callm static Relax.Console.Print(Relax.String)```Теперь пройдемся по каждой строчке кода. В первой строчке мы создаем главный класс с названием MainClass. Во второй строчке создаем метод Main, который является точкой входа в программу. На третьей строчке мы указываем, что максимум значений на стеке будет 1. На четвертой строчке мы помещаем на стек строку "Hello, world!", а на пятой строчке вызываем метод вывода строки на консоль.# Документация### RVM инструкции.1. `mclass` создает главный класс, то есть класс, в котором есть метод _Main_. В аргументы принимает название класса, который нужно создать. Данная инструкция относится к верхнему уровню.	Пример записи:	```	mclass MyProgram	```2. `new` создает новый объект заданного класса и помещает на стек. Данная инструкция относится к нижнему уровню. Из стека принимает значения, которые передаются в параметры конструктора. В параметры принимает:	* _Класс, объект которого нужно создать_.	* _Список параметров_. В скобках через запятую перечисляются типы данных параметров нужного нам конструктора.	Примеры записей:	```	new Relax.Object()	new Dog(Relax.Int32)	new Cat(Relax.Int32, Relax.String)	```3. `class` создает новый класс. В аргументы принимает название класса, который нужно создать. Данная инструкция относится к верхнему уровню.		Пример записи:	```	class Cat	```4. `method` создает метод класса. Данная инструкция относится к верхнему уровню. В параметры принимает:	* Модификатор доступа:		* public		* private		* protected	* Статичность		* static		* instance	* Имя класса, в который нужно добавить метод.	* Имя метода	* Список параметров(нужно указывать тип данных и имя)	Пример записи:	```	method public static MainClass.PrintStrInt(Relax.String str, Relax.Int32 num):		;code...	```5. `callm` вызывает методы класса. Данная инструкция относится к нижнему уровню. В параметры принимает:	* _Класс, в котором находится метод_. Записывается полное имя класса.	* _Список параметров_. В скобках через запятую перечисляются типы данных параметров нужного нам метода.	Пример записи:	```	callm std static Relax.Console.Write(Relax.String)	```6. `get` добавляет на стек значение локальной переменной. В параметры принимает имя локальной переменной. Данная инструкция относится к нижнему уровню. В байт-коде пишется не имя, а четырёхбайтовый id	Пример записи:	```	get myVar	```7. `push.str` добавляет Relax.String на стек. Строку, которую нужно добавить, инструкция принимает в параметры. Данная инструкция относится к нижнему уровню.	Пример записи:	```	push.str "hello world"	```8. `push.int32` добавляет Relax.Int32 на стек. В параметры принимает число, которое нужно добавить. Данная инструкция относится к нижнему уровню.	Пример записи:	```	push.int32 56	```9. `return` выходит из метода и, в случае если возвращаемый тип данных не равен void из стека будет браться значение и записываться в стек родительского фрейма. Данная инструкция относится к нижнему уровню.	Пример записи:	```	return	```10. `set` устанавливает значение локальной переменной. В аргументы принимает название локальной переменной. Со стека берет значение и присваивает его в локальную переменную. Данная инструкция относится к нижнему уровню.	Пример записи:	```	set lol	```11. `local` создает локальную переменную с определенным типом данных. В аргументы принимает название переменной и тип данных. Данная инструкция относится к нижнему уровню.	Пример записи:	```	local var Relax.String	```12. `add` операция сложения. Складывает 2 числовых значения со стека и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	add	```	Пример кода:	```	push.int 10	push.int 90	add	```	После выполнения этого кода на стеке будет число 100.13. `dup` получает объект со стека и вставляет его на стек дважды. Данная инструкция относится к нижнему уровню.	Пример записи:	```	dup	```14. `jmp` перемещает выполнение кода на определенную метку. В параметры принимает название метки. А в байт-коде она принимает число, означающее количество инструкций на которое нужно переместить выполнение кода, относительно начала метода. Данная инструкция относится к нижнему уровню. 	Пример записи:	```	jmp tag	```    Как создавать метки?    ```    tag:    ```15. `jmpif` то же самое, что и jmp, но перемещает выполнение кода только, если на стеке лежит значение true типа данных Relax.Bool. Данная инструкция относится к нижнему уровню.		Пример записи:	```	jmpif tag	```16. `gc` очищает мусор в куче. Использовать её вам вряд ли понадобится, так как RVM каждые 20 инструкций сама очищает мусор. Данная инструкция относится к нижнему уровню.	Пример записи:	```	gc	```17. `newarr` создает Relax.Array определенного типа, который передается в аргументы, и с определенным размером, который берется со стека. Ссылка на созданный массив помещается на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	newarr Relax.Int32	```	Особенность типа Relax.Array. Чтобы создать переменную под массив нужно в угловых скобках указать тип, который хранит массив.	Пример:	```	local myArr Relax.Array<Relax.String>	newarr Relax.String	set myArr	```18. `getarr` получает данные из массива по индексу. Со стека берет ссылку на массив и индекс типа Relax.Int32. Затем помещает на стек значение из массива. Данная инструкция относится к нижнему уровню.	Пример записи:	```	getarr	```	Пример использования:	```	push.int32 10 ;Индекс	get arr ;Получение ссылки на массив	getarr	```    19. `setarr` устанавливает данные в массиве по индексу. Со стека берет ссылку на массив, индекс типа Relax.Int32, в который нужно установить значение, и само значение. Данная инструкция относится к нижнему уровню.	Пример записи:	```	setarr	```	Пример использования:	```	push.str "я - десятый элемент в массиве" ;Значение(допустим у нас массив строк)	push.int32 10 ;Индекс	get arr ;Получение ссылки на массив	setarr	```20. `push.bool` помещает значение Relax.Bool на стек. В аргументы принимает true или false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	push.bool true	```21. `push.float` помещает значение Relax.Float на стек. В аргументы принимает число с точкой. Данная инструкция относится к нижнему уровню.		Пример записи:	```	push.float 3.14	```22. `sub` операция вычитания. Вычитает из первого числового значения со стека второе значение и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	sub	```	Пример кода:	```	push.int 10	push.int 90	sub	```	После выполнения этого кода на стеке будет число 80.23. `mul` операция умножения. Умножает 2 числовых значения со стека и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	mul	```	Пример кода:	```	push.int 10	push.int 90	mul	```	После выполнения этого кода на стеке будет число 900.24. `div` операция деления. Делит первое числовое значение со стека на второе значение и помещает результат на стек. Данная инструкция относится к нижнему уровню.	Пример записи:	```	div	```	Пример кода:	```	push.int 10	push.int 90	div	```	После выполнения этого кода на стеке будет число 9.25. `cast` приводит значение к другому типу данных и результат помещает на стек. В параметры принимает тип данных, к которому нужно привести значение. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cast Relax.Int32	```	Пример кода:	```	push.float 3.14	cast Relax.Int32	```	После выполнения этого кода на стеке будет число 3(Relax.Int32).26. `.maxstack` указывает размер стека в методе. От размера стека зависит то, сколько значений может там находится одновременно. Вызывать эту инструкцию нужно один раз в методе. Если её не вызывать, то размер стека будет равен нулю. Данная инструкция относится к нижнему уровню.		Пример записи:	```	.maxstack 2	```	Пример использования:	```	.maxstack 1	push.int32 456	callm static Relax.Console.Print(Relax.Int32)	```	Пример ошибки:	```	.maxstack 1	push.int32 456	push.str "hello world"	callm static Relax.Console.Print(Relax.String)	callm static Relax.Console.Print(Relax.Int32)	```	Ошибка заключается в том, что в стеке одновременно находится 2 значения, а максимальное значение в нашем случае равно 1.27. `ref` создает указатель на значение со стека. В параметры принимает тип данных указателя. На стек помещает созданный указатель типа Relax.Pointer. Данная инструкция относится к нижнему уровню.		Пример записи:	```	ref Relax.Int32	```	Пример кода:	```	push.int32 10	ref Relax.Int32	local pointer Relax.Pointer<Relax.Int32>	set pointer	```	Как вы могли заметить переменные указателя объявляются по тому же принципу, что и массивы.28. `deref` берет со стека указатель и возвращает на стек значение этого указателя. Данная инструкция относится к нижнему уровню.		Пример записи:	```	deref	```	Пример кода:	```	push.int32 10	ref Relax.Int32	deref	callm static Relax.Console.Print(Relax.Int32)	```	Запись числа 10 на стек -> создание указателя на число 10 -> разыменование указателя, тем самым, получая исходное число 10 -> вывод числа на консоль. 29. `setpd` устанавливает новое значение по адресу, на который указывает указатель. Данная инструкция относится к нижнему уровню.		Пример записи:	```	setpd	```	Пример кода:	```	local var Relax.Int32 ;Объявление переменной, с которой будем манипулировать	local pointer Relax.Pointer<Relax.Int32> ; Указатель, который будет указывать на переменную var	push.int32 10	set var ;Устанавливаем в переменную var значение 10	get var	ref Relax.Int32	set pointer ;Создаем указатель на переменную var и присваиваем её в указатель pointer	push.int32 20	get pointer	setpd ;Меняем значение переменной var через указатель pointer	get var	callm static Relax.Console.Print(Relax.Int32) ;Выводим новое значение переменной var	```30. `field` создает поле класса. Данная инструкция относится к верхнему уровню.	В параметры принимает:	* Статичность(static или instance)	* Тип данных	* Название содержащего поле класса	* Имя поля	Пример записи:	```	field instance Relax.Int32 Dog.Speed	```31. `getfield` получает значение поля объекта со стека и помещает его на стек. В параметры принимает название поля. Данная инструкция относится к нижнему уровню.		Пример записи:	```	getfield Fieldname	```	Пример кода:	```	new Dog() ;Создаем объект класса Dog	getfield Name ;Получаем поле Name у созданного объекта	```32. `setfield` устанавливает значение поля объекта со стека. Значение берется на стеке. В параметры принимает название поля. Данная инструкция относится к нижнему уровню.		Пример записи:	```	setfield Fieldname	```	Пример кода:	```	new Dog() ;Создаем объект класса Dog	push.str "Shery"	setfield Name ;Присваиваем полю Name значение "Shery"	```33. `this` получает ссылку на объект из которого вызван метод и записывает её на стек. Используется только в instance-методах. При использовании его в static-методе на стек запишется null. Данная инструкция относится к нижнему уровню.		Пример записи:	```	this	```34. `ce` получает со стека 2 примитива и сравнивает их, если они равны, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	ce	```	Пример кода:	```	push.int32 10	push.int32 10	ce	```	В результате на стеке будет лежать значение true.35. `cl` получает со стека 2 примитива и сравнивает их, если первый меньше второго, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cl	```	Пример кода:	```	push.int32 10	push.int32 6	cl	```	В результате на стеке будет лежать значение true, потому что 6 меньше 10.36. `cb` получает со стека 2 примитива и сравнивает их, если первый больше второго, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cb	```	Пример кода:	```	push.int32 6	push.int32 10	cb	```	В результате на стеке будет лежать значение true, потому что 10 больше 6.37. `cle` получает со стека 2 примитива и сравнивает их, если первый меньше или равен второму, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cle	```	Пример кода:	```	push.int32 10	push.int32 10	cle	```	В результате на стеке будет лежать значение true, потому что 10 равен 10.	Пример кода 2:	```	push.int32 10	push.int32 6	cle	```	В результате на стеке будет лежать значение true, потому что 6 меньше 10.38. `cbe` получает со стека 2 примитива и сравнивает их, если первый больше или равен второму, то на стек записывается true, иначе false. Данная инструкция относится к нижнему уровню.		Пример записи:	```	cbe	```	Пример кода:	```	push.int32 10	push.int32 10	cbe	```	В результате на стеке будет лежать значение true, потому что 10 равен 10.	Пример кода 2:	```	push.int32 6	push.int32 10	cbe	```	В результате на стеке будет лежать значение true, потому что 10 больше 6.### Relasm инструкцииТут описаны инструкции, которые не компилируются в байт-код, они существуют лишь в Relasm.1. `import` данная инструкция импортирует relasm-файл. В параметры принимает путь до файла. Она относится к верхнему уровню.		Пример записи:	```	import lib.rasm	```2. Метки. Метки нужны чтобы при помощи инструкций jmp, jmpif перемещатся на них. Они относятся к нижнему уровню.		Пример записи:	```	tag:	```	Пример кода:	```	forever:	push.str "hello world"	callm static Relax.Console.Print(Relax.String)	jmp forever	```	Это бесконечный цикл, который выводит hello world на консоль.### Std библиотека.Тут описаны все классы, методы, функции, поля, которые есть по-умолчанию в RVM.* `Relax.Console`. Данный класс нужен для работы с консолью.		Методы:	* `void Print(...)`. Данный метод нужен для вывода чего-либо на консоль. У него есть несколько перегрузок: Print(Relax.String), Print(Relax.Int32), Print(Relax.Float), Print(Relax.Bool). В операционной системе Windows он использует функцию WriteConsole из WinAPI, благодаря чему может выводить Unicode, но из-за этого у неё есть и минусы, если вы с ними столкнулись, то используйте метод Write.	* `void Write(...)`. Данный метод использует поток std::cout из С++, из-за этого он не может выводить Unicode в операционной системе Windows, а так же работает медленнее, чем Print. У него есть те же перегрузки, что и у Print.	* `Relax.String Input()`. Данный метод считывает unicode строку с консоли и возвращает её. В операционной системе Windows использует функцию из WinAPI под названием ReadConsole. Если у вас возникнут проблемы с этим методов, то используйте метод Read.	* `Relax.String Read()`. Этот метод считывает строку с консоли и возвращает её. Она работает при помощи потока std::cin в С++.* `Relax.Converter`. Данный класс нужен чтобы конвертировать типы данных.		Методы:	* `Relax.String ToString(...)`. Данный метод нужен чтобы привести какое-либо значение к строке. У него есть несколько перегрузок: ToString(Relax.Int32), ToString(Relax.Float), ToString(Relax.Bool). Полученную строку метод возвращает.	* `Relax.Int32 ToInt32(Relax.String)`. Данный метод конвертирует Relax.String в Relax.Int32. Если в строке хранится НЕ число, то вы получите ошибку "Relax.Converter.ToInt32: conversion error".	* `Relax.Float ToFloat(Relax.String)`. Данный метод конвертирует Relax.String в Relax.Float. Если в строке хранится НЕ дробное число, то вы получите ошибку "Relax.Converter.ToFloat: conversion error". В качестве разделителя используется символ '.'.	* `Relax.Bool ToBool(Relax.String)`. Данный метод конвертирует Relax.String в Relax.Bool. Если строка не равна "true" или "false", то вы получите ошибку "Relax.Converter.ToBool: conversion error".* `Relax.Array`. Данный класс является реализацией массива.	Методы:	* `Relax.Int32 Size()`. Данный метод возвращает размер массива в виде Relax.Int32.* `Relax.Random`. Данный класс нужен для генерации случайных чисел.		Методы:	* `Relax.Int32 GenerateInt32(...)`. Данный метод генерирует случайное число Relax.Int32 и возвращает его. Он имеет 2 перегрузки:		* GenerateInt32(). Генерирует абсолютно случайное число.		* GenerateInt32(Relax.Int32, Relax.Int32). Генерирует случайное число в диапозоне. Первый параметр отвечает за минимальное число, второй за максимальное.* `Relax.File`. Данный класс нужен для работы с файлами.		Методы:	* `Relax.String ReadAll(Relax.String)`. Данный метод считывает весь файл и возвращает результат. Путь до файла принимает в параметры. Путь до файла может быть как полным, так и относительным.